# Talk Code to Me
##Computer anatomy, machine code, OSes, and programming languages

Everything on a computer is written in some sort of programming language--including the browser you're viewing this on, the code that makes this site look the way it does, the code that makes computers connect to the internet, and the code that makes computers run. But a lot of programming languages are also very expressive; they let you type “if pie == good then eat_pie()” and it’ll know what you mean! But how can you tell a computer something that sounds a lot like English and expect it to do something? To understand that, we have to go all the way down into the heart of a computer. (Sorry, not heart.. brain. Computers don't have hearts.)

At the lowest level, computers use binary (0s and 1s) to store and manipulate information. They have a CPU (central processing unit) which does all the calculation and RAM (random access memory) which stores all the information that you're currently working with. To store data you need to keep around, you put it on your hard drive disk. A good metaphor is thinking of it like a desk in your office: you're the CPU that's doing stuff, but all your paperwork (data) is in your drawers (hard drive disk). You need to pull that work out of your drawers and onto your desk (your RAM) before you can work on it. After you're done, if you like it, you put it back into your drawers and walk away from your desk (shutting down your PC).

But how do we actually manipulate those 0s and 1s? At the lowest level, the CPU does very, very simple but important operations like flipping 0s to 1s, 1s to 0s, and moving things around in memory. This is done with something called **machine code** or **machine language**, which is really just a set of commands in binary that correspond to certain actions that the CPU can perform. This combination of machine code and instructions are referred to as the "instruction set" of a CPU. For example, here's a fictional instruction set that a CPU might use:

Machine Code - Instruction
0000         - STORE
0001         - LOAD
0010         - ADD
0100         - HALT

If this all seems like insanity so far to you, don't worry. You will never need to do this by hand as a web developer, but it's important to have at least a general idea of how it works so we can go on to explain how operating systems (OSs) like Windows, Mac OSX, and Linux can work on top of a computer’s hardware. If you find the concepts here interesting, then you might be interested in reading the absolutely phenomenal book [Code by Charles Petzold](http://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319), which goes in depth into how a computer is built from a single relay to fully-fledged software.

After we have machine code, we have operating systems, which are just software built on top of the machine code. You’re using one right now (Mac OS X, Windows, or some version of Linux). Operating systems help implement all sorts of things like graphics, networking, filesystems, and more by integrating with hardware (graphics, networking, sound cards, and more) and the CPU and RAM. All the files on your computer really are is just your operating system deciding that a certain section of your hard disk drive is a specific file. Add on the ability to visibly browse your hard drive disk and you have what's commonly referred to as a **filesystem**. Slap on a graphical user interface and a networking card and you've got yourself a recipe for the web. Let's move a level up and discuss programming languages.

Because our operating system itself deals with presenting us with a really nice, usable GUI (graphical user interface), file browsing and all sorts of other commands, we can more easily develop programs that interact with the OS's filesystem, networking card, and more without ever having to touch the machine code ourselves. But what tools do we use to develop those programs? You guessed it: programming languages. And yet, we can't just say "`if pie == good then eat_pie()`"--how is the CPU all the way down there supposed to know what we mean by that? We have to define the rules of our programming languages first, and then convert that half-math-half-caveman style of English into machine code itself. This is done with something called a **compiler**, a program that converts (“compiles”) code written according to a certain set of rules into machine code. The very first compilers were written by hand, in machine code itself! Nowadays we have enough programming languages that we can actually use *other* programming languages to write compilers for our *new* programming languages, because it all compiles down to machine code in the end. Is that crazy or what?

So to summarize this pretty mind-bending section: we started at 0s and 1s and made higher-level directions that execute our lower-level directions, all the way up to fully-fledged English-ish programming languages that get compiled all the way down back to machine code that move those 0s and 1s around. This act of creating a higher-level structure out of low-level information is known in computer science as **abstraction**, because you're *abstracting* the details away. By interacting with our hardware through programming, we create meaning out of these tiny little 0s and 1s and rejoice at the resulting pattern of little lights.

![](http://imgs.xkcd.com/comics/computer_problems.png)

Next, let’s talk about how our programming languages implement networking--and what that means for the web! Now that we've got the intricate, low-level stuff out of the way, things are going to speed up significantly. From here on out, we won't be going into nearly as much detail because we're approaching things that you'll be learning in depth through the rest of the prework and in class.

(Technical note: The programming languages that you'll be learning at MakerSquare, Ruby and JavaScript, are actually *not* compiled languages. They are **interpreted** languages, which means that instead of being compiled and then run as machine code, a separate program called an **interpreter** reads your programs and executes them as they are being read. This means that you don't need to have a compile step, which makes developing in interpreted languages significantly faster. Interpreted languages are also often very expressive, but as a tradeoff, their execution tends to be a little bit slower. This performance difference doesn't really matter for much of web applications development.)

----
